RBAC
root@master:~# kubectl -n devops get role,rolebindings.rbac.authorization.k8s.io
NAME                                     CREATED AT
role.rbac.authorization.k8s.io/devrole   2025-01-15T21:51:32Z

### this role is having some permissions with it. 
NAME                                                ROLE           AGE
rolebinding.rbac.authorization.k8s.io/devrolebind   Role/devrole   14h
root@master:~# kubectl -n devops describe role devrole
Name:         devrole
Labels:       <none>
Annotations:  <none>
PolicyRule:
  Resources         Non-Resource URLs  Resource Names  Verbs
  ---------         -----------------  --------------  -----
  pods              []                 []              [create update delete list get]  <------------- permission that the role can perform
  secrets           []                 []              [create update delete list get]  <------------- permission that the role can perform
  deployments.apps  []                 []              [create update delete list get]  <------------- permission that the role can perform
root@master:~#

### rolebinding devrole is binded to the user aneesh
root@master:~# kubectl -n devops describe rolebindings.rbac.authorization.k8s.io devrolebind
Name:         devrolebind
Labels:       <none>
Annotations:  <none>
Role:
  Kind:  Role
  Name:  devrole
Subjects:
  Kind  Name    Namespace
  ----  ----    ---------
  User  aneesh
root@master:~#


### Proccess of the autherization
Kubectl will be sending a request to kubeapi server and kubeapi server will be doing the authentication and autherization.
How this user is coming into the picture that is getting authenticated and is getting autherization. Whenever we are working with the kubernetes cluster, you will see the hidden directory 
called (.kube) this file is gereneted when you are doing the kubeadm configuration in the begining of setting up the server


aneesh $ mkdir .cert
aneesh $ ls

### Create Key and CSR 
aneesh $ openssl genrsa -out aneesh.key 2048
Generating RSA private key, 2048 bit long modulus (2 primes)
............................+++++
..............................+++++
e is 65537 (0x010001)
aneesh $ ls
aneesh.key  filesystem  snap
aneesh $ 

aneesh $ openssl req -new -key aneesh.key -out aneesh.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:aneesh
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
aneesh $ 
aneesh $ ls
aneesh.csr  aneesh.key  filesystem  snap
aneesh $ 

### Decode the aneesh.csr with base64
aneesh $ cat aneesh.csr | base64 -w 0
### for security, I have removed a lot of strings from it
LS0tLS1CRUdJTiBDRVJUSU
ZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ216QWt
HQTFVRUJoTUNRVlV4RXpBUkJnTlZCQWdNQ2xOdmJXVXRV
M1JoZEdVeApJVEFmQmdOVkJBb01HRWx1ZEdWeWJtVjBJRmRwWkdkcGRITWdVSFI1SUV4MFpERVBNQTBHQTFVRUF3d0dZVzVsClpYTm9NSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXZ5dEE0ckd1YW10b1A4WmkKanMrZjJONU80QVBCQ0dDWDY1TWNldVJjNCsybUFXQmJIZ2FiRGhBYnNwd3JmMWdDeStUTW1wUFJqL0V4dml0cApwVTJ6a2RnVkNUMi8rRVEzbWFKeW9kdWxvZWZTbldicG05QjR6YndwMFBXb2hxUG9RS0dYcDNxdTdveHp6b2t3ClB6SEVTQlppaWk0RVRCdVRnK0QwKzViWnppQ2tYL1hNSXJ5Ym1taVNKbnN3NmZLVHJqZG9hbkhhMHhGdGlmcWMKWURIbFNsaXB0YlEwSkp2VzdGWVAySWpnZDVNT3dlU1Z3d1czRVZ3bFhHTmVicExuY0xQT29rK2J3cnhJVEFodQpZTGZQVS8vSGRRRHFHUWpBaDZ1MUVuR1g3MlN5UEJHRXJqbENKZUJQMFdLRGFoSTRCUkI5cTFESitWUWx2MU01CnYxemxTd0lEQVFBQm9BQXdEUVl
aneesh $ 

### Copy your decoded csr key above and plug in the yaml file, we will be creating the certifcate by using the csr, you will be doing it through the kubernetes cluster: meaning through kubernetes we will be signing our certificate
aneesh $ nano csr.yaml 
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: aneesh
spec:
  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ216Q0NBWU1DQVFBd1ZqRUxNQWtHQTFVRUJoTUNRVlV4RXpBUkJnTlZCQWdNQ2xOdmJXVXRVM1JoZEdVeApJVEFmQmdOVkJBb01HRWx1ZEdWeWJtVjBJRmRwWkdkcGRITWdVSFI1SUV4>
  signerName: kubernetes.io/kube-apiserver-client
  expirationSeconds: 86400 #one day
  usages: 
  - client auth
